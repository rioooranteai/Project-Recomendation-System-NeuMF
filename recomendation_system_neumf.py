# -*- coding: utf-8 -*-
"""Recomendation System - NeuMF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DAQdb-Yd3Nw0O_RnSb_12XPh6xklEFCY

# **Import Modules**

Mengimpor pustaka atau modul yang diperlukan untuk manipulasi data, visualisasi, pemrosesan model machine learning, dan pelatihan model neural network. Fokus utama dari kode ini adalah menyiapkan lingkungan dan dependensi yang dibutuhkan untuk membaca data, melakukan praproses, membangun arsitektur model berbasis embedding dan dense layer, serta menyiapkan mekanisme pelatihan yang stabil dengan bantuan callback untuk menghindari overfitting
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import kagglehub
import os
import warnings
import tensorflow as tf

from sklearn.preprocessing import LabelEncoder
from tensorflow import keras
from tensorflow.keras import layers
from sklearn.model_selection import StratifiedShuffleSplit
from tensorflow.keras.layers import (
    Input, Embedding, Flatten, Dropout, Dense, Concatenate,
    BatchNormalization, Multiply
)
from tensorflow.keras.regularizers import l2
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import ReduceLROnPlateau, EarlyStopping

warnings.filterwarnings('ignore')

"""# **Download Dataset**

Proses mengunduh dataset `Goodbooks-10k` dari Kaggle secara langsung ke lingkungan kerja menggunakan kagglehub, lalu mencetak path atau lokasi direktori tempat dataset tersebut disimpan. Langkah ini penting untuk memastikan bahwa file dataset telah tersedia secara di colab.
"""

path = kagglehub.dataset_download("zygmunt/goodbooks-10k")

print("Path to dataset files:", path)

"""# **Load Dataset**

Me-load dua file utama dari dataset, yaitu `books.csv` dan `ratings.csv`, ke dalam bentuk DataFrame. Setelah itu, data rating diurutkan kolomnya agar sesuai dengan kebutuhan dan lebih rapi.
"""

books = pd.read_csv(path + "/books.csv")
ratings = pd.read_csv(path + "/ratings.csv")

"""# **Data Understanding**

Pada tahap awal *Data Understanding*, dilakukan dua fungsi dasar mengenai data yang akan digunakan. Dua fungsi tersebut adalah `info()` dan `describe()`.

* Fungsi `info()` digunakan untuk melihat struktur data secara umum, seperti jumlah baris, nama kolom, tipe data setiap kolom, serta jumlah nilai yang tidak null.
* Sedangkan fungsi `describe()` digunakan untuk melihat statistik deskriptif dari kolom-kolom numerik, seperti nilai minimum, maksimum, rata-rata, standar deviasi, serta kuartil.
"""

ratings.info()

books.info()

ratings.describe()

books.describe()

"""## Distribusi Rating

Memvisualisasikan distribusi nilai rating yang diberikan oleh pengguna terhadap buku. Dengan menggunakan diagram batang, grafik ini menunjukkan seberapa sering setiap nilai rating (1 - 5) diberikan dalam dataset.
"""

plt.figure(figsize=(8, 5))
sns.countplot(data=ratings, x='rating', palette='coolwarm')
plt.title('Distribusi Rating Pengguna')
plt.xlabel('Rating')
plt.ylabel('Jumlah')
plt.grid(True)
plt.show()

"""Berdasarkan grafik distribusi rating pengguna, terlihat bahwa mayoritas pengguna cenderung memberikan rating tinggi, dengan rating 4 menjadi yang paling banyak diberikan, disusul oleh rating 5. Sebaliknya, rating rendah seperti 1 dan 2 jarang diberikan, menunjukkan bahwa pengguna cenderung memiliki persepsi positif terhadap film yang mereka tonton. Rating 3 sebagai nilai tengah juga cukup banyak muncul, mencerminkan adanya penilaian netral. Distribusi ini bersifat positif atau condong ke arah rating tinggi, yang merupakan pola umum dalam data rating film. Pola ini penting untuk diperhatikan saat membangun sistem rekomendasi, karena kecenderungan pengguna memberikan rating tinggi dapat memengaruhi cara model dalam membedakan preferensi antar pengguna.

## Rating per-User

Memvisualisasikan sebaran jumlah buku yang dirating oleh setiap pengguna. Dengan menghitung jumlah rating per `user_id`, kemudian menampilkannya dalam bentuk histogram, grafik ini membantu mengidentifikasi apakah sebagian besar pengguna hanya memberikan sedikit rating atau ada pengguna yang sangat aktif.
"""

user_rating_count = ratings.groupby('user_id')['book_id'].count()

plt.figure(figsize=(10, 4))
sns.histplot(user_rating_count, bins=50, kde=True)
plt.title('Distribusi Jumlah Rating per Pengguna')
plt.xlabel('Jumlah Buku yang Dirating')
plt.ylabel('Jumlah Pengguna')
plt.grid(True)
plt.show()

"""Dari histogram “Distribusi Jumlah Rating per Pengguna” di atas, dapat dilihat bahwa mayoritas pengguna hanya memberi rating pada sejumlah kecil buku (misalnya 1–5 buku), di mana puncak tertinggi (sekitar 20.000 pengguna) berada pada bin paling kiri (pengguna yang memberi rating sangat rendah). Seiring meningkatnya jumlah buku yang dirating per pengguna, jumlah pengguna menurun drastis—misalnya hanya beberapa ribu pengguna yang merating sekitar 10–20 buku, dan semakin sedikit lagi (beberapa ratus atau puluhan saja) yang merating puluhan hingga ratusan buku. Kurva kepadatan mempertegas pola ini: sangat “menonjol” di nilai rendah dan kemudian memerah ke kanan dengan ekor panjang hingga sekitar 200 buku. Artinya, distribusi ini sangat miring ke kanan (right-skewed): sebagian besar pengguna bersifat “casual” dengan sedikit interaksi (sedikit memberi rating), sedangkan hanya segelintir “power user” yang banyak merating buku.

## Rating Per-Book

Memvisualisasikan distribusi jumlah rating yang diterima oleh setiap buku. Dengan menghitung berapa banyak pengguna yang memberi rating pada masing-masing `book_id`, kemudian menampilkannya dalam histogram, grafik ini membantu menunjukkan apakah sebagian besar buku hanya memiliki sedikit rating atau ada buku tertentu yang sangat populer.
"""

book_rating_count = ratings.groupby('book_id')['user_id'].count()

plt.figure(figsize=(10, 4))
sns.histplot(book_rating_count, bins=50, kde=True, color='orange')
plt.title('Distribusi Jumlah Rating per Buku')
plt.xlabel('Jumlah Rating yang Diterima Buku')
plt.ylabel('Jumlah Buku')
plt.grid(True)
plt.show()

"""Dari histogram tersebut terlihat bahwa hampir seluruh buku dalam dataset mengumpulkan jumlah rating yang sangat tinggi—terkonsentrasi di kisaran 90–100—sementara sangat sedikit buku yang mendapat rating di bawah 50, sehingga distribusinya tampak sangat miring ke kanan; hal ini menandakan bahwa data kemungkinan hanya mencakup buku-buku populer yang sudah memiliki basis pembaca/rater besar, sehingga nilai rata‐rata jumlah rating per buku menjadi sangat dekat dengan batas atas (100).

## Hitung Missing Value

Memeriksa apakah ada nilai yang hilang (missing values) dalam dataset `books.csv` dan `ratings.csv`. Dengan menghitung jumlah nilai kosong pada setiap kolom, kemudian menampilkan hanya kolom-kolom yang memiliki data hilang
"""

missing_books = books.isnull().sum()
missing_books = missing_books[missing_books > 0]
print("Missing values di books.csv:")
print(missing_books)

"""Masih terdapat beberapa detail tentang buku yang tidak lengkap. Namun hal ini tidak akan menjadi masalah karena fokus kita adalah melakukan Collaborative Filtering User-Based dengan fokus pada data rating saja."""

missing_rating = ratings.isnull().sum()
missing_rating = missing_rating[missing_rating > 0]
print("Missing values di rating.csv:")
print(missing_rating)

"""Seluruh buku telah dirating oleh pengguna

# **Data Preparation**

## Pemisahan Fitur dan Target

Pemisahan data fitur dan target untuk model rekomendasi, di mana X berisi pasangan pengguna dan buku, dan y berisi nilai rating.
"""

X = ratings[['user_id', 'book_id']].values
y = ratings['rating'].values

"""## Train-Test Split

Distribusi rating tidak seimbang sehingga pembagian data train dan validasi dilakukan menggunakan `StratifiedShuffleSplit` agar proporsi rating pada kedua set tetap terjaga dengan rasio 80:20.

"""

splitter = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)

for train_idx, val_idx in splitter.split(X, ratings['rating']):
    X_train, X_val = X[train_idx], X[val_idx]
    y_train, y_val = y[train_idx], y[val_idx]

"""# **Modeling**

# **NeuMF (Neural Matrix Factorization)**

Pada project ini, salah satu model yang digunakan adalah **NeuMF** (Neural Matrix Factorization), sebuah model rekomendasi yang menggabungkan pendekatan **Generalized Matrix Factorization** (GMF) dan **Multi-Layer Perceptron** (MLP) untuk memodelkan interaksi non-linear antara pengguna dan item. Biasanya, NeuMF dirancang untuk menangani persoalan personalized ranking berbasis implicit feedback seperti klik atau pembelian. Namun, dalam eksperimen ini saya memodifikasi model tersebut untuk menangani masalah explicit feedback, yaitu prediksi rating numerik secara langsung. Perubahan utama terletak pada layer output yang diubah menjadi layer regresi linear dengan fungsi aktivasi linear, sehingga model dapat memprediksi skor rating kontinu. Selain itu, saya menggunakan loss function MSE (Mean Squared Error) dan metrik seperti MAE dan RMSE yang lebih sesuai untuk evaluasi prediksi nilai rating.

![image.png](data:image/png;base64,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)

## Parameter Dasar

- `embedding_dim (32)`: Ukuran vektor embedding untuk merepresentasikan pengguna dan item. Semakin besar nilai ini, model bisa menangkap pola lebih kompleks, tapi berisiko overfitting dan butuh komputasi lebih.

- `l2_reg_emb (1e-4)`: Besaran regularisasi L2 pada embedding untuk mencegah bobot menjadi terlalu besar. Membantu mengurangi overfitting dengan menjaga bobot tetap kecil dan stabil.

- `dropout_rate (0.5)`: Proporsi neuron yang secara acak dimatikan saat pelatihan untuk mencegah overfitting. Nilai 0.5 berarti 50% neuron dropout, sehingga model lebih tahan terhadap ketergantungan berlebihan pada fitur tertentu.
"""

embedding_dim = 32
l2_reg_emb = 1e-4
dropout_rate = 0.5

"""## Input Layer

* Layer ini berfungsi sebagai titik masuk data ke jaringan saraf.
* **Parameter `shape=(1,)`** berarti input yang diterima berupa tensor berdimensi 1 dengan panjang 1, yaitu satu nilai integer yang mewakili ID pengguna atau ID buku.
* **Parameter `name`** memberi nama pada layer untuk memudahkan identifikasi saat debugging atau visualisasi model.


"""

# Input Layer
user_input = Input(shape=(1,), name='user_input')
book_input = Input(shape=(1,), name='book_input')

"""## GMF Branch
Tujuan dari menghitung `n_users = ratings['user_id'].nunique()` dan `n_books = ratings['book_id'].nunique()` adalah untuk **menentukan ukuran input** dari layer embedding `Embedding()` dalam model, khususnya untuk GMF (Generalized Matrix Factorization) pada model NeuMF. Ringkasnya`n_users` dan `n_books` digunakan untuk memastikan layer embedding memiliki kapasitas untuk menangani seluruh ID unik dari user dan book dalam data. Tanpa ini, model tidak akan tahu berapa banyak representasi yang harus dipelajari.


**1. Embedding Layer (`user_emb_gmf` dan `book_emb_gmf`)**

* **Fungsi:** Mengubah input ID pengguna (`user_input`) dan ID buku (`book_input`), yang berupa angka diskrit, menjadi representasi vektor berdimensi tetap (`embedding_dim = 32`).
* **Parameter penting:**

  * `input_dim` menentukan jumlah total kategori (jumlah pengguna `n_users` atau buku `n_books`), sehingga embedding dapat memetakan setiap ID unik ke vektor.
  * `output_dim` menentukan ukuran vektor embedding, yang mengontrol kompleksitas representasi.
  * `embeddings_regularizer=l2(l2_reg_emb)` menambahkan regularisasi L2 untuk mencegah bobot embedding menjadi terlalu besar dan overfitting.

**2. Flatten Layer (`user_vec_gmf`, `book_vec_gmf`)**

* **Fungsi:** Mengubah output embedding yang berbentuk tensor 2D `(batch_size, 1, embedding_dim)` menjadi tensor 1D `(batch_size, embedding_dim)` agar bisa diproses oleh layer selanjutnya.

**3. Multiply Layer (`gmf_vector`)**

* **Fungsi:** Melakukan perkalian elemen-per-elemen (element-wise multiplication) antara vektor embedding pengguna dan buku.
* **Tujuan:** Memodelkan interaksi linier antara fitur pengguna dan item, mirip dengan dot product di matrix factorization klasik, tetapi dengan kemampuan untuk digabungkan dengan jaringan lain (MLP).

"""

n_users = ratings['user_id'].nunique()
n_books = ratings['book_id'].nunique()

# Embedding Layer
user_emb_gmf = Embedding(
    input_dim=n_users,
    output_dim=embedding_dim,
    embeddings_regularizer=l2(l2_reg_emb),
    name='user_emb_gmf'
)(user_input)
book_emb_gmf = Embedding(
    input_dim=n_books,
    output_dim=embedding_dim,
    embeddings_regularizer=l2(l2_reg_emb),
    name='book_emb_gmf'
)(book_input)

# Flatten Layer
user_vec_gmf = Flatten()(user_emb_gmf)
book_vec_gmf = Flatten()(book_emb_gmf)

# Multiply Layer
gmf_vector = Multiply()([user_vec_gmf, book_vec_gmf])

"""## MLP Branch

**1. Embedding Layer (`user_emb_mlp` dan `book_emb_mlp`)**

* Sama seperti di GMF, layer ini mengubah ID pengguna dan buku menjadi vektor embedding berdimensi 32, dengan regularisasi L2 untuk mencegah overfitting.
* Tujuannya adalah menyediakan representasi fitur yang bisa dipelajari dan diolah lebih lanjut oleh jaringan MLP.

**2. Flatten Layer (`user_vec_mlp` dan `book_vec_mlp`)**

* Mengubah tensor embedding berdimensi `(batch_size, 1, embedding_dim)` menjadi vektor 1D `(batch_size, embedding_dim)` agar bisa diproses oleh lapisan Dense.

**3. Concatenate Layer (`mlp_input`)**

* Menggabungkan vektor embedding pengguna dan buku menjadi satu vektor berdimensi dua kali embedding\_dim (64).
* Ini memberikan informasi lengkap tentang pengguna dan item secara bersamaan untuk diproses oleh MLP.

**4. Dense Layer Stack (MLP)**

* **Dense Layer 1:** 64 neuron dengan aktivasi ReLU, dilengkapi regularisasi L2 kecil (`1e-5`), batch normalization, dan dropout 50% untuk stabilitas dan mencegah overfitting.
* **Dense Layer 2:** 32 neuron dengan aktivasi ReLU dan regularisasi serta dropout yang sama seperti sebelumnya.
* **Batch Normalization:** Membantu mempercepat pelatihan dan menstabilkan distribusi aktivasi.
* **Dropout:** Mengurangi risiko overfitting dengan secara acak menonaktifkan 50% neuron selama pelatihan.


"""

# Embedding Layer
user_emb_mlp = Embedding(
    input_dim=n_users,
    output_dim=embedding_dim,
    embeddings_regularizer=l2(l2_reg_emb),
    name='user_emb_mlp'
)(user_input)

book_emb_mlp = Embedding(
    input_dim=n_books,
    output_dim=embedding_dim,
    embeddings_regularizer=l2(l2_reg_emb),
    name='book_emb_mlp'
)(book_input)

# Flatten Layer
user_vec_mlp = Flatten()(user_emb_mlp)
book_vec_mlp = Flatten()(book_emb_mlp)

# Concatenate Layer
mlp_input = Concatenate(name='mlp_concat')([user_vec_mlp, book_vec_mlp])

# Dense Layer Stack (MLP)
mlp = Dense(64, activation='relu',
            kernel_regularizer=l2(1e-5),
            name='mlp_dense_1')(mlp_input)
mlp = BatchNormalization()(mlp)
mlp = Dropout(dropout_rate)(mlp)

mlp = Dense(32, activation='relu',
    kernel_regularizer=l2(1e-5),
    name='mlp_dense_3')(mlp)
mlp = BatchNormalization()(mlp)
mlp = Dropout(dropout_rate)(mlp)

"""## Concat MLP Branch & GMF Branch

* **Concatenate Layer** yang menggabungkan output dari dua cabang:

  * `gmf_vector` (hasil dari GMF branch — interaksi linier)
  * `mlp` (hasil dari MLP branch — interaksi non-linear)

* **Fungsi:** Menggabungkan dua jenis representasi interaksi (linier dan non-linier) dalam satu vektor sebagai masukan untuk prediksi akhir.

* **Hasil:** Vektor gabungan yang lebih kaya informasi dan mampu menangkap pola interaksi pengguna-item yang sederhana maupun kompleks.
"""

# 5. Gabungkan GMF & MLP
neumf_concat = Concatenate(name='neumf_concat')([gmf_vector, mlp])

"""## Output Layer (Regresi Rating)

**1. Dense Layer (`prediction`)**

* Layer ini menghasilkan output akhir berupa **prediksi rating eksplisit** (nilai kontinu, seperti 1–5).
* **Units = 1**: Hanya satu neuron output karena hanya memprediksi satu nilai rating per pasangan user–item.
* **Activation = 'linear'**: Fungsi aktivasi linear digunakan agar output tidak dibatasi, sesuai untuk tugas regresi.
* **Kernel Initializer = 'lecun\_uniform'**: Strategi inisialisasi bobot yang cocok untuk aktivasi linear, memastikan stabilitas saat pelatihan.
* **Kernel Regularizer = L2 (`1e-5`)**: Regularisasi L2 membantu mencegah overfitting dengan menghukum bobot yang terlalu besar.

**2. Model API (`model`)**

* `Model(inputs=[user_input, book_input], outputs=prediction)` membuat objek model dengan dua input (ID pengguna dan ID buku) dan satu output (rating).
* Ini menyatukan keseluruhan arsitektur: input → GMF & MLP → gabungan → output regresi.
"""

# 6. Output layer (regresi rating) dengan L2 pada kernel
prediction = Dense(
    1,
    activation='linear',
    kernel_initializer='lecun_uniform',
    kernel_regularizer=l2(1e-5),
    name='prediction'
)(neumf_concat)

model_neu = Model(inputs=[user_input, book_input], outputs=prediction)

"""## Compile Model

**1. Optimizer (`Adam`)**

* Menggunakan **Adam** (Adaptive Moment Estimation), yaitu optimizer yang secara otomatis menyesuaikan learning rate selama pelatihan.
* **Learning Rate = 1e-4**: Nilai yang relatif kecil untuk memastikan proses pembelajaran berjalan stabil dan perlahan menghindari local minima.


**2. Compile**

### Loss Function:

* **MSE (Mean Squared Error)** digunakan karena ini adalah tugas regresi.

  $$
  \text{MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2
  $$


### Metrics:

* **MAE (Mean Absolute Error)**
  Mengukur rata-rata selisih absolut antara nilai aktual dan prediksi.
  Rumus:

  $$
  \text{MAE} = \frac{1}{n} \sum_{i=1}^{n} \left| y_i - \hat{y}_i \right|
  $$

* **RMSE (Root Mean Squared Error)**
  Akar dari MSE, memberi penalti lebih besar pada error yang besar.
  Rumus:

  $$
  \text{RMSE} = \sqrt{ \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2 }
  $$


**3. Model Summary**

* Menampilkan struktur model lengkap: nama layer, output shape, jumlah parameter, dan total parameter yang bisa dilatih.
"""

# 7. Compile dengan learning rate lebih rendah
optimizer = Adam(learning_rate=1e-4)
model_neu.compile(optimizer=optimizer, loss='mse', metrics=['mae', tf.keras.metrics.RootMeanSquaredError()])
model_neu.summary()

"""## Training Model

**1. EarlyStopping Callback**

EarlyStopping digunakan untuk menghentikan proses pelatihan lebih awal jika model tidak menunjukkan peningkatan pada data validasi.

* `monitor='val_loss'`: Memantau nilai loss pada data validasi.
* `patience=10`: Jika tidak ada peningkatan dalam 10 epoch berturut-turut, pelatihan dihentikan.
* `restore_best_weights=True`: Setelah pelatihan dihentikan, bobot model akan dikembalikan ke nilai terbaik.
* `verbose=1`: Menampilkan pesan saat pelatihan dihentikan lebih awal.

**2. Model Training dengan `.fit()`**

Model dilatih menggunakan data pelatihan dan dievaluasi pada data validasi di setiap epoch.

* Input terdiri dari dua fitur: ID pengguna dan ID buku.
* Target yang diprediksi adalah rating eksplisit (`y_train`).
* `validation_data`: Menyediakan data validasi untuk pemantauan performa model.
* `epochs=50`: Maksimal jumlah epoch, namun bisa berhenti lebih cepat jika EarlyStopping aktif.
* `batch_size=1024`: Jumlah sampel yang digunakan dalam satu kali update parameter.
* `callbacks=[early_stop]`: Mengaktifkan fungsi EarlyStopping.
* `verbose=1`: Menampilkan progress pelatihan secara ringkas per epoch.
"""

early_stop = EarlyStopping(
    monitor='val_loss',
    patience=10,
    restore_best_weights=True,
    verbose=1
)

history_neu = model_neu.fit(
    [X_train[:, 0], X_train[:, 1]], y_train,
    validation_data=([X_val[:, 0], X_val[:, 1]], y_val),
    epochs=50,
    batch_size=1024,
    callbacks=[early_stop],
    verbose=1
)

"""## Rekomendasi Top-N

Fungsi ini menghasilkan rekomendasi **Top-N buku** untuk seorang user berdasarkan model prediksi (misalnya NeuMF). Langkah-langkahnya:

1. **Encode `user_id`** → indeks integer.
2. **Ambil daftar buku yang sudah dirating user.**
3. **Cari buku-buku yang belum dirating.**
4. **Prediksi rating** user terhadap semua buku yang belum dirating.
5. **Ambil N buku dengan prediksi tertinggi.**
6. **Mapping kembali ke `book_id`, ambil info judul & penulis dari DataFrame `books`.**
7. **Kembalikan hasil dalam bentuk DataFrame dan tampilkan ke layar.**
"""

import numpy as np
import pandas as pd

def get_top_n_recommendations(model, ratings, books, user_id, N=10):

    rated_books_by_user = set(
        ratings.loc[ratings['user_id'] == user_id, 'book_id'].tolist()
    )

    all_books = ratings['book_id'].unique()

    unrated_books = np.array(
        [b for b in all_books if b not in rated_books_by_user],
        dtype=np.int32
    )

    if unrated_books.size == 0:
        print(f"User {user_id} sudah merating semua buku.")
        return pd.DataFrame(columns=['book_id', 'pred_rating', 'title', 'authors'])

    user_array = np.full(shape=(len(unrated_books),), fill_value=user_id, dtype=np.int32)
    book_array = unrated_books

    preds = model.predict([user_array, book_array], batch_size=4096, verbose=0).flatten()

    top_n_indices = np.argsort(preds)[::-1][:N]
    top_books = unrated_books[top_n_indices]
    top_scores = preds[top_n_indices]

    results = []
    for book_id, score in zip(top_books, top_scores):
        match = books[books['id'] == book_id]

        if not match.empty:
            title = match['title'].values[0]
            author = match['authors'].values[0]
        else:
            title = "(Unknown Title)"
            author = "(Unknown Author)"

        results.append({
            'book_id': book_id,
            'pred_rating': score,
            'title': title,
            'authors': author
        })

    top_n_df = pd.DataFrame(results)

    print(f"\nTop {N} recommendations for user {user_id}:\n")
    for idx, row in top_n_df.iterrows():
        print(f"Book ID: {row['book_id']}, Predicted Rating: {row['pred_rating']:.4f}")
        print(f"Title:  {row['title']}")
        print(f"Author: {row['authors']}")
        print("-" * 30)

get_top_n_recommendations(model_neu, ratings, books, user_id=4, N=10)

"""# **Evaluasi**

# **NeuMF (Neural Matrix Factorization)**

## Visualisasi Kurva Loss

Plot ini digunakan untuk memantau performa model selama proses pelatihan. Kurva menunjukkan bagaimana nilai **loss** pada data pelatihan (`Train Loss`) dan data validasi (`Validation Loss`) berubah seiring bertambahnya epoch.

* Sumbu **x** menunjukkan jumlah epoch (iterasi pelatihan).
* Sumbu **y** menunjukkan nilai loss (MSE) pada masing-masing epoch.
* Kurva **Train Loss** mencerminkan seberapa baik model mempelajari data pelatihan.
* Kurva **Validation Loss** menunjukkan generalisasi model terhadap data yang tidak dilatih.

Tujuan dari visualisasi ini adalah untuk mendeteksi tanda-tanda **overfitting** (misalnya, ketika `val_loss` meningkat sementara `loss` terus menurun) atau **underfitting** (kedua kurva tetap tinggi). Idealnya, kedua kurva menurun dan saling berdekatan.
"""

plt.figure(figsize=(12, 10))

plt.plot(history_neu.history['loss'], label='Train Loss')
plt.plot(history_neu.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""Interpretasi

Pada awal pelatihan (epoch 0–1), nilai loss untuk data training dan validasi sangat tinggi (sekitar 15 dan 13) karena bobot model masih diinisialisasi secara acak. Namun, pada epoch pertama, terjadi penurunan drastis: loss training turun menjadi sekitar 7 dan loss validasi menjadi sekitar 3,5, menunjukkan bahwa model mulai mampu mengenali pola interaksi pengguna dan item. Pada epoch 1 hingga 5, loss terus menurun dengan cepat—training loss mencapai sekitar 2,5 dan validation loss mendekati 1,1—menandakan bahwa NeuMF berhasil menyesuaikan bobot embedding dan lapisan dense secara efektif. Setelah epoch ke-5, penurunan loss berjalan lebih lambat (epoch 5–15), dengan training loss turun dari ≈2,5 ke ≈1,1 dan validation loss dari ≈1,1 ke ≈0,8, menandakan model mulai mendekati konvergensi. Dari epoch 15 hingga 37, nilai loss keduanya konsisten berada pada kisaran 0,7–0,9 dengan selisih yang sangat kecil—bahkan terkadang validation loss lebih rendah—yang menunjukkan tidak terjadi overfitting dan model mampu melakukan generalisasi dengan baik. Karena kurva loss sudah melandai sejak sekitar epoch ke-25, pelatihan tambahan hanya memberikan peningkatan yang sangat minim.

## Visualisasi Kurva MAE

Kurva ini digunakan untuk memantau **Mean Absolute Error (MAE)** model selama proses pelatihan.

* Sumbu **x** menunjukkan jumlah epoch.
* Sumbu **y** menunjukkan nilai MAE, yaitu rata-rata selisih absolut antara prediksi model dan nilai rating sebenarnya.
* **Train MAE** menunjukkan performa model pada data pelatihan.
* **Validation MAE** menunjukkan seberapa baik model melakukan generalisasi pada data yang tidak dilatih.

MAE memberikan gambaran intuitif tentang rata-rata besar kesalahan model. Pola ideal adalah ketika kedua kurva menurun dan berada cukup dekat, yang menandakan model belajar dengan baik dan tidak overfitting.
"""

plt.figure(figsize=(12, 10))

plt.plot(history_neu.history['mae'], label='Train MAE')
plt.plot(history_neu.history['val_mae'], label='Validation MAE')
plt.title('Model MAE')
plt.xlabel('Epoch')
plt.ylabel('MAE')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""Interpretasi

Pada awal pelatihan (epoch 0–1), nilai MAE (Mean Absolute Error) sangat tinggi, dengan MAE training sekitar 3,7 dan MAE validasi sekitar 3,5, yang mencerminkan prediksi awal model masih jauh dari nilai sebenarnya. Namun, penurunan tajam terjadi dalam beberapa epoch pertama: pada epoch ke-3, MAE training sudah turun ke kisaran 1,5 dan MAE validasi ke sekitar 1,0. Hal ini menunjukkan bahwa model NeuMF sangat cepat menangkap pola dasar dari interaksi pengguna dan item. Dari epoch 4 hingga 15, penurunan MAE masih terus berlangsung meski melambat; MAE training turun secara bertahap dari sekitar 1,3 menjadi 0,75, dan MAE validasi dari 0,95 menjadi sekitar 0,65. Selanjutnya, pada epoch 15–30, baik MAE training maupun validasi mendatar di kisaran 0,6–0,7, menandakan model mulai mencapai konvergensi. Menariknya, pada beberapa titik (sekitar epoch 30 ke atas), MAE validasi sedikit lebih tinggi daripada MAE training, namun selisihnya sangat kecil, sehingga tidak mengindikasikan overfitting signifikan. Secara keseluruhan, kurva MAE yang menurun konsisten dan mendatar menunjukkan bahwa model mampu belajar secara efektif dan menghasilkan prediksi rating yang cukup akurat serta stabil di data validasi.

## Visualisasi Kurva RMSE

Plot ini menunjukkan perubahan **Root Mean Squared Error (RMSE)** selama pelatihan model.

* Sumbu **x** menunjukkan jumlah epoch.
* Sumbu **y** menunjukkan nilai RMSE, yaitu akar dari rata-rata kuadrat selisih antara prediksi dan nilai sebenarnya.
* **Train RMSE** menggambarkan akurasi model terhadap data pelatihan.
* **Validation RMSE** menunjukkan performa model pada data validasi (yang tidak dilatih).

RMSE lebih sensitif terhadap error yang besar dibanding MAE, sehingga sangat berguna untuk mendeteksi prediksi yang jauh meleset.
Kurva yang ideal adalah saat kedua garis (train dan validation) turun dan relatif dekat, menandakan model belajar dengan baik dan tidak overfitting.
"""

plt.figure(figsize=(12, 10))

plt.plot(history_neu.history['root_mean_squared_error'], label='Train RMSE')
plt.plot(history_neu.history['val_root_mean_squared_error'], label='Validation RMSE')
plt.title('Model RMSE')
plt.xlabel('Epoch')
plt.ylabel('RMSE')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""Interpretasi

Pada awal pelatihan (epoch 0–1), nilai RMSE (Root Mean Squared Error) sangat tinggi, dengan RMSE training mencapai hampir 3,9 dan RMSE validasi sekitar 3,7. Ini wajar karena model belum belajar dan bobot masih acak. Namun, terjadi penurunan drastis pada beberapa epoch pertama: pada epoch ke-3, RMSE training turun ke sekitar 2,0, sementara RMSE validasi sudah turun mendekati 1,2. Ini menunjukkan bahwa model NeuMF mampu dengan cepat menangkap pola interaksi pengguna–item. Dari epoch 4 hingga 15, penurunan RMSE berlanjut meskipun mulai melambat—RMSE training menurun dari sekitar 1,6 menjadi 0,9, dan RMSE validasi dari sekitar 1,0 menjadi 0,83. Mulai epoch 15 ke atas hingga akhir pelatihan (epoch 37), kurva RMSE cenderung datar, berada di kisaran 0,75–0,9. Pada epoch terakhir, RMSE training sedikit lebih rendah daripada RMSE validasi, tetapi perbedaannya sangat kecil dan stabil. Ini menandakan tidak ada overfitting yang signifikan, dan model berhasil mempertahankan kemampuan generalisasi yang baik. Penurunan RMSE yang konsisten dan stabil juga memperkuat bukti bahwa prediksi model semakin akurat dari waktu ke waktu, meskipun peningkatannya semakin kecil seiring bertambahnya epoch.

# **Kesimpulan**

Berdasarkan keseluruhan hasil plot untuk metrik Loss, MAE, dan RMSE selama 37 epoch pelatihan, dapat disimpulkan bahwa model NeuMF menunjukkan performa pelatihan yang sangat baik dan stabil. Ketiga metrik tersebut mengalami penurunan drastis pada beberapa epoch pertama, menandakan bahwa model dengan cepat mampu mempelajari pola interaksi antara pengguna dan item. Setelah itu, penurunan metrik berlangsung lebih lambat namun konsisten, hingga akhirnya mencapai fase konvergensi tanpa tanda-tanda overfitting—ditunjukkan oleh selisih yang kecil antara nilai training dan validation, bahkan pada epoch-epoch akhir. Hal ini membuktikan bahwa model tidak hanya mampu menyesuaikan diri dengan data pelatihan, tetapi juga mengeneralisasi dengan baik terhadap data yang belum pernah dilihat. Dengan MAE dan RMSE akhir yang rendah dan stabil, model dapat dianggap cukup akurat dalam memprediksi rating user terhadap item, serta siap untuk diimplementasikan lebih lanjut atau digunakan sebagai dasar sistem rekomendasi.
"""